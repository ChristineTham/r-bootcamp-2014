<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>When do I start programming?</title>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}

pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>When do I start programming?</h1>

<blockquote>
<p>“[W]e wanted users to be able to begin in an interactive environment,
where they did not consciously think of themselves as programming.
Then as their needs became clearer and their sophistication increased,
they should be able <strong>to slide gradually into programming, when the
language and system aspects would become more important</strong>.”</p>
</blockquote>

<p><a href="http://www.stat.bell-labs.com/S/history.html">John Chambers, “Stages in the Evolution of S”</a></p>

<h3>Acknowledgement</h3>

<p><a href="http://adv-r.had.co.nz/">Advanced R</a> by Hadley Wickham.</p>

<h1>Key Principles</h1>

<ul>
<li>Everything that exists is an object.</li>
<li><p>Everything that happens is a function call.</p>

<p><a href="http://user2014.stat.ucla.edu/files/chambers.pdf">John Chambers&#39; useR!2014 talk</a></p></li>
</ul>

<h3>What does the 2nd principle mean?</h3>

<p>Are arithmetic operations really just functions?</p>

<pre><code class="r">3+2
</code></pre>

<pre><code>## [1] 5
</code></pre>

<pre><code class="r">&#39;+&#39;(3,2)
</code></pre>

<pre><code>## [1] 5
</code></pre>

<p>What about indexing?</p>

<pre><code class="r">x=matrix(runif(100),10)
x[,2]
</code></pre>

<pre><code>##  [1] 0.2187 0.3264 0.3875 0.4279 0.5447 0.7049 0.5942 0.5702 0.4206 0.2102
</code></pre>

<pre><code class="r">&#39;[&#39;(x,,2)
</code></pre>

<pre><code>##  [1] 0.2187 0.3264 0.3875 0.4279 0.5447 0.7049 0.5942 0.5702 0.4206 0.2102
</code></pre>

<h3>What does the 1st principle mean?</h3>

<pre><code class="r">class(1)
</code></pre>

<pre><code>## [1] &quot;numeric&quot;
</code></pre>

<pre><code class="r">class(runif)
</code></pre>

<pre><code>## [1] &quot;function&quot;
</code></pre>

<pre><code class="r">class(function(x) x^2)
</code></pre>

<pre><code>## [1] &quot;function&quot;
</code></pre>

<pre><code class="r">square = function(x) x^2
class(square)
</code></pre>

<pre><code>## [1] &quot;function&quot;
</code></pre>

<h1>So what is a function in R?</h1>

<p>You&#39;ve been working with functions for at least a day now and you&#39;ve
probably started to get an informal feel for them.  Now it is time to make
those informal notions more precise.</p>

<blockquote>
<p>In computer programming, a subroutine is <strong>a sequence of program
instructions that perform a specific task, packaged as a unit</strong>. This unit
can then be used in programs wherever that particular task should be
performed. Subprograms may be defined within programs, or separately in
libraries that can be used by multiple programs.</p>
</blockquote>

<p><a href="http://en.wikipedia.org/wiki/Function_(computer_science)">http://en.wikipedia.org/wiki/Function_(computer_science)</a></p>

<p>Technically, R has more than one type of function, but we will only
consider the most important type called a <strong>closure</strong>.  Closures are a
general programming construct that roughly mean a callable (i.e.,
subroutine) and a referencing environment.</p>

<p>A closure has three components:</p>

<ul>
<li>its formals (its argument list)</li>
<li>its body (expr in the statement below)</li>
<li>its environment which provides the enclosure of the evaluation frame when the closure is used</li>
</ul>

<p>Consider this generic function</p>

<blockquote>
<p>function( arglist ) expr</p>
</blockquote>

<ul>
<li><code>arglist</code> corresponds to the function&#39;s formals</li>
<li><code>expr</code> corresponds to the function&#39;s body</li>
<li>the environment provides the context for the evaluation of the body</li>
</ul>

<pre><code class="r">square = function(x) x^2
environment(square)
</code></pre>

<pre><code>## &lt;environment: 0xc01fb0&gt;
</code></pre>

<pre><code class="r">formals(square)
</code></pre>

<pre><code>## $x
</code></pre>

<pre><code class="r">body(square)
</code></pre>

<pre><code>## x^2
</code></pre>

<h3>But what do they do?</h3>

<p>Functions in R return an object.</p>

<p><strong>Pure functions</strong> always return the same object when given the same input.
You should try to stick with pure functions as much as possible, because
they are the easiest kind to reason about.</p>

<p><strong>Side effects</strong> are when a function affects the state of the world in
addition to its return value.  Can you think of any side effects that
you saw an R function produce from yesterday?  What about:</p>

<ul>
<li><code>library</code></li>
<li><code>setwd</code></li>
<li><code>plot</code></li>
</ul>

<p><strong>Copy-on-modify</strong> means that if you modify an argument inside the
function it will not change the original value.  This protects you from
a major potential source of side effects.  (There are exceptions to this
rule.)</p>

<h1>Function arguments</h1>

<p>We will return to the enivornment and body in a moment.  First let&#39;s look
a bit more closely at the formal argument.  Formal arguments are part of
the function definition and don&#39;t change based on how the function is
called.  When a function is called it will be called with some actual
arguments.</p>

<p>How does R map the actual arguments of a function call in a specific
instance to the formal arguments of its definition?</p>

<pre><code class="r">args(runif)
</code></pre>

<pre><code>## function (n, min = 0, max = 1) 
## NULL
</code></pre>

<pre><code class="r">runif(5)
</code></pre>

<pre><code>## [1] 0.3031 0.2853 0.9758 0.3916 0.2704
</code></pre>

<pre><code class="r">runif(min=0, 5)
</code></pre>

<pre><code>## [1] 0.800055 0.308644 0.951594 0.003139 0.658697
</code></pre>

<pre><code class="r">runif(min=0, 5, 2)
</code></pre>

<pre><code>## [1] 0.5338 0.1854 0.8518 0.1210 0.7612
</code></pre>

<pre><code class="r">runif(min=0, max=5, 2)
</code></pre>

<pre><code>## [1] 4.322 1.141
</code></pre>

<pre><code class="r">runif(5, 0, 2)
</code></pre>

<pre><code>## [1] 0.5230 1.7460 0.2198 0.3167 1.0428
</code></pre>

<pre><code class="r">runif(5, max=2)
</code></pre>

<pre><code>## [1] 0.2919 0.3510 1.4224 1.5323 0.9276
</code></pre>

<pre><code class="r">runif(5, ma=2)
</code></pre>

<pre><code>## [1] 0.78916 0.28644 0.58832 0.06318 1.10533
</code></pre>

<pre><code class="r">runif(5, m=2)
</code></pre>

<pre><code>## Error: argument 2 matches multiple formal arguments
</code></pre>

<p>R first tries to match the actual arguments to the formal arguments by
exact name, then by prefix matching, and finally by position.</p>

<p>WARNING:  Using prefix matching may occassionally save some typing
when you are doing interactive work that you plan to discard.  However,
when you are writing code and saving it in a file, you should
normally be explicit.</p>

<h1>Lexical scope</h1>

<p>Now let&#39;s quickly look at what the environment involves.  We&#39;ve
already encountered environments.</p>

<pre><code class="r">ls()
</code></pre>

<pre><code>## [1] &quot;square&quot; &quot;x&quot;
</code></pre>

<p>An environment in R is a data structure that associates a set of names
with a set of values.</p>

<pre><code class="r">e &lt;- new.env()
e$add &lt;- &#39;+&#39;
e$x &lt;- &quot;a&quot;
e$y &lt;- rnorm(10)
class(e)
</code></pre>

<pre><code>## [1] &quot;environment&quot;
</code></pre>

<pre><code class="r">e
</code></pre>

<pre><code>## &lt;environment: 0xfa5b48&gt;
</code></pre>

<pre><code class="r">ls(e)
</code></pre>

<pre><code>## [1] &quot;add&quot; &quot;x&quot;   &quot;y&quot;
</code></pre>

<p>In particular, it is an unordered collection of
names and values (or keys and values if you are familiar with
dictionaries).</p>

<pre><code class="r">e[1]
</code></pre>

<pre><code>## Error: object of type &#39;environment&#39; is not subsettable
</code></pre>

<pre><code class="r">e[[1]]
</code></pre>

<pre><code>## Error: wrong arguments for subsetting an environment
</code></pre>

<p>NOTE: Environments are not lists.</p>

<p>Every environment (except the <strong>empty</strong> one) has a parent environment.</p>

<pre><code class="r">.GlobalEnv
</code></pre>

<pre><code>## &lt;environment: R_GlobalEnv&gt;
</code></pre>

<pre><code class="r">parent.env(e)
</code></pre>

<pre><code>## &lt;environment: 0xc01fb0&gt;
</code></pre>

<pre><code class="r">environmentName(parent.env(e))
</code></pre>

<pre><code>## [1] &quot;&quot;
</code></pre>

<p>Since each environment has a parent (back to the root empty one),
this produces a unique path from the immediate environment
back to the empty one.</p>

<pre><code class="r">search()
</code></pre>

<pre><code>##  [1] &quot;.GlobalEnv&quot;        &quot;package:foreign&quot;   &quot;package:knitr&quot;    
##  [4] &quot;package:stats&quot;     &quot;package:graphics&quot;  &quot;package:grDevices&quot;
##  [7] &quot;package:utils&quot;     &quot;package:datasets&quot;  &quot;Autoloads&quot;        
## [10] &quot;package:base&quot;
</code></pre>

<p>How does R look up symbol values?  To answer this it is helpful to
introduce some new vocabulary.</p>

<p><strong>Scope</strong> refers to which variables a given piece of code can access.</p>

<p>R uses <strong>lexical scoping</strong>: functions can access variables in their own scope relative to where they are <strong>defined</strong> (<strong>not</strong> relative to where they are called).</p>

<p>Just look up one level &hellip;</p>

<pre><code class="r">x &lt;- 2
f &lt;- function() {
    y &lt;- 1
    c(x, y)
}
f()
</code></pre>

<pre><code>## [1] 2 1
</code></pre>

<pre><code class="r">a &lt;- 1
b &lt;- 2

f &lt;- function(x)  a*x + b

g &lt;- function(x) {
    a &lt;- 2
    b &lt;- 1
    f(x)
}

g(2)
</code></pre>

<pre><code>## [1] 4
</code></pre>

<pre><code class="r">f &lt;- function(a, b) {
    return(function(x) a*x + b)
}

g &lt;- f(2, 1)
g(2)
</code></pre>

<pre><code>## [1] 5
</code></pre>

<p>When a function is made it gets a reference to its enclosing environment.</p>

<pre><code class="r">environment(f)
</code></pre>

<pre><code>## &lt;environment: 0xc01fb0&gt;
</code></pre>

<h1>Writing functions</h1>

<p>In module 4, we sorted the earnings dataframe based on two of its
columns.</p>

<pre><code class="r">library(foreign)
earnings &lt;- read.dta(&quot;../data/heights.dta&quot;)
ord &lt;- order(earnings$earn, earnings$height, decreasing=TRUE)
earnings_ordered &lt;- earnings[ord, ]
</code></pre>

<p>How would we encapsulate that functionality generically so that
we can apply it to other dataframes (or matrices)?</p>

<pre><code class="r">colSorter &lt;- function(data.matrix, col1, col2) {
    # Sorts a matrix or dataframe based on one or more columns
    #
    # Args:
    #     data.matrix: a dataframe or matrix with at least 2 numeric columns
    #                  and any number of rows
    #     col1: a reference to the column to sort on
    #     col2: a reference to the column to use for ties
    #
    # Returns:
    #     &lt;data.matrix&gt; sorted in increasing order by the values
    #     in the first column. Any ties should be broken by values
    #     in the second column. The row pairs should be maintained
    #     in this matrix

    ordered.idcs &lt;- order(data.matrix[, col1], data.matrix[, col2], decreasing=TRUE)
    sorted.matrix &lt;- data.matrix[ordered.idcs, ]
    return(sorted.matrix)
}

identical(earnings_ordered, colSorter(earnings, &quot;earn&quot;, &quot;height&quot;))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>What are the differenct functions parts for colSorter?</p>

<pre><code class="r">environment(colSorter)
</code></pre>

<pre><code>## &lt;environment: 0xc01fb0&gt;
</code></pre>

<pre><code class="r">formals(colSorter)
</code></pre>

<pre><code>## $data.matrix
## 
## 
## $col1
## 
## 
## $col2
</code></pre>

<pre><code class="r">body(colSorter)
</code></pre>

<pre><code>## {
##     ordered.idcs &lt;- order(data.matrix[, col1], data.matrix[, 
##         col2], decreasing = TRUE)
##     sorted.matrix &lt;- data.matrix[ordered.idcs, ]
##     return(sorted.matrix)
## }
</code></pre>

<p>Where did the comments go?</p>

<pre><code class="r">attributes(colSorter)$srcref
</code></pre>

<pre><code>## function(data.matrix, col1, col2) {
##     # Sorts a matrix or dataframe based on one or more columns
##     #
##     # Args:
##     #     data.matrix: a dataframe or matrix with at least 2 numeric columns
##     #                  and any number of rows
##     #     col1: a reference to the column to sort on
##     #     col2: a reference to the column to use for ties
##     #
##     # Returns:
##     #     &lt;data.matrix&gt; sorted in increasing order by the values
##     #     in the first column. Any ties should be broken by values
##     #     in the second column. The row pairs should be maintained
##     #     in this matrix
## 
##     ordered.idcs &lt;- order(data.matrix[, col1], data.matrix[, col2], decreasing=TRUE)
##     sorted.matrix &lt;- data.matrix[ordered.idcs, ]
##     return(sorted.matrix)
## }
</code></pre>

<p>Note: Return results via return() statement <strong>or</strong> last line evaluated</p>

<h1>Writing functions with invisible return</h1>

<pre><code class="r">colSorter(earnings, &quot;earn&quot;, &quot;height&quot;)[1:5, 1:5]
</code></pre>

<pre><code>##        earn height1 height2 sex race
## 1860 200000       5      10   1    1
## 583  175000       5      11   1    1
## 351  170000       5      11   1    1
## 618  148000       5       7   1    1
## 314  125000       6       2   1    1
</code></pre>

<pre><code class="r">colSorter &lt;- function(data.matrix, col1, col2) {
    # Sorts a matrix or dataframe based on one or more columns
    #
    # Args:
    #     data.matrix: a dataframe or matrix with at least 2 numeric columns
    #                  and any number of rows
    #     col1: a reference to the column to sort on
    #     col2: a reference to the column to use for ties
    #
    # Returns:
    #     &lt;data.matrix&gt; sorted in increasing order by the values
    #     in the first column. Any ties should be broken by values
    #     in the second column. The row pairs should be maintained
    #     in this matrix

    ordered.idcs &lt;- order(data.matrix[, col1], data.matrix[, col2], decreasing=TRUE)
    sorted.matrix &lt;- data.matrix[ordered.idcs, ]
    return(invisible(sorted.matrix))
}

colSorter(earnings, &quot;earn&quot;, &quot;height&quot;)
colSorter(earnings, &quot;earn&quot;, &quot;height&quot;)[1:5, 1:5]
</code></pre>

<pre><code>##        earn height1 height2 sex race
## 1860 200000       5      10   1    1
## 583  175000       5      11   1    1
## 351  170000       5      11   1    1
## 618  148000       5       7   1    1
## 314  125000       6       2   1    1
</code></pre>

<pre><code class="r">histNormal &lt;- function(N) {
  vals &lt;- rnorm(N)
  hist(vals)
  invisible(max(vals))
}

histNormal(1000)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/> </p>

<pre><code class="r">max &lt;- histNormal(1000)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/> </p>

<pre><code class="r">max
</code></pre>

<pre><code>## [1] 3.371
</code></pre>

<h1>User-defined functions V: multiple arguments, default values</h1>

<pre><code class="r">newFunction &lt;- function(num, threshold=0, modifier=2) {
  if (num &lt; threshold) {
    return(num / modifier)
  } else {
    return(num * modifier)
  }
}
newFunction(2.6)
</code></pre>

<pre><code>## [1] 5.2
</code></pre>

<p>R lazily matches arguments from left to right:</p>

<pre><code class="r">newFunction(2.6, 3)
</code></pre>

<pre><code>## [1] 1.3
</code></pre>

<pre><code class="r">newFunction(2.6, 3, 1.3)
</code></pre>

<pre><code>## [1] 2
</code></pre>

<p>But we can explicitly specify which argument is which:</p>

<pre><code class="r">newFunction(2.6, modifier=1.3, threshold=3)
</code></pre>

<pre><code>## [1] 2
</code></pre>

<p>And we can pass the other arguments to most pre-defined R functions:</p>

<pre><code class="r">hist(sapply(rnorm(10000), newFunction), breaks=60, freq=FALSE)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/> </p>

<pre><code class="r">hist(sapply(rnorm(10000), newFunction, modifier=1), breaks=60, freq=FALSE)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/> </p>

<h1>User-defined functions VI: <code>...</code> argument</h1>

<pre><code class="r">args(hist)
</code></pre>

<pre><code>## function (x, ...) 
## NULL
</code></pre>

<pre><code class="r">histNormalWrapper &lt;- function(N, ...) {
  vals &lt;- rnorm(N)
  hist(vals, ...)
}

histNormalWrapper(1000)
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAAC2VBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZpSoxAAAA83RSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSVFVWWFlaW1xdXl9gYmNkZWZnaGlqa2xtbm9wcXJzdHV3eHl6e3x9foCBgoWGh4iJiouMjY6QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK6vsLGys7S1tre4uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fz9/v+OCMacAAAACXBIWXMAAAsSAAALEgHS3X78AAAPAElEQVR4nO3djX9VdR3A8d9lOLYxNq4EDC0T25iohVJpFimaYaWlCWmZmWVPGpk92HPuIpE5fCAtRDEJK2RYNlNDoXiQpMB2WQ8gFDLHxsMuifX7C9rdw+Xu3Pv7ee+55957zvl+3q8Xe732++17z9n9sIez3W1KAQAAAAAAAAAAAAAAAAAAAACAkNC6SqkqrQf+pTQ0RAq50et7dHO29RHHQFmlwo/ZvNmx6t5+vXRStnXC+0cqfOZqITdanXWd8P5x7C3+2WeVmrrm4MsrX9+/qJPvqz/6fN/zV/W/zAUbDj515uBHgxl/uP51d+082rWqKfncF7u3zLx++5E/zhi6scGBhuT4u5LPL9NfV2qhXpQ2kjoGykvrHR0dO4Y/xq/TT2zST6qO/tWpaq5OtCX0Fers/+rN2w8Ovkin/kyb3rfqz/pPyecO79JHj64/qIc+SAwNTEyOz0wuvF+vVep5fU7aSOoYKC89ZCDKqKN69vjFt0cG3w9s1lepq/QG9Zj+vorcOfgi36s97sfLZ6oztK7sf+7syVq/R03Xrw7e1vBA6iNFZc+r0Un6xUjayLFjoKwGGw2/xa/R+m+31g2uRo7oejVeH47s029Q6uTBF6lVavTVy7f9t/8F+p+r6H/BmtRH7tTAsU8R7tPzrtKL0keOHQNlNTL8cdc9o/Xv08LX6yOjDuopSp2YuuJ7QG+86bzhiskXHBE+OXAs/EV66VJ99siR4WOgrEaEj9x2kzpTv5IsNzb5nvtKdaXepNbrb6lILBU+oZvUrGzhUwPHwo/uemnPrsiIkdQxUFYj3+I36cfW6qeV6tPLJ6t5OrE6+cndZVpv2Pq/VPi/6h2/7P9Ub2xm+OGBtKvBu7X+gWNk+Bgoq5Hhm35z4NCv36jUzQd6T1GRq/+c2Jq8nPvotr4NF6bCv/25w8/O2qnnZYZPDRwLf37/Z4COkeFjwO++G7tcHfdxvbPc54ESe1jrl/u0vqXc54ESq7nlhUTPxk9y5Q0AAAAAAAAAAAAAAAAAAAAAAACnaEv8UCK+kB/+l6attbm6pim2qtzngRLrrUw+jewu93mgxNa0Tquuaoy1lfs8UGLRBfG+ROei+nKfBwCgaLicE4rLOaEyLufmLBnw84+X7ZRydfISm9vLfXo+l3E5Vzd1wA3zy3hSubn4tqkW6/m1hFamy7l5nyvH2eTl4q/Zdn9HeFcILxThQ65pXfedo1Vtxp/hIHzIPfPlife0EF6eA9WqYksT4cXZfo5SF62tJ7w0lx2+V6lYB+HFOel8pSLv/IZzmfBCEV4owgtFeKEILxThhSK8UIQXivBCEV4owgtFeKEILxThhSK8UIQXivBCEV4owgtFeKEILxThhSK8UIQXKvDh171tpsWEUp1k4AQ+fM+CmNmyBaU6ycAJfvgKy+bbbvP4XMKD8EIRXijCC0V4oQgvFOGFIrxQhBeK8EIRXijCC0V4oQgvFOGFIrxQhBeK8EIRXijCC0V4oQgvlD/CT7T9ScFPfMs2Snh3/BH+D7Y/IrrpMdso4d3xR/inbJvffNy2S3h3CC8U4YUivFCEF4rwQhFeKMILRXihCC8U4YUivFCEF4rwQhFeKMILRfiQi7bEDyXiC+uc64QPubbW5uqaptgq5zrhQ663Mvk0stu5TviQW9M6rbqqMdbmXCd8yEUXxPsSnYvqneuEF4rwQhE+5O6pmryiZ+9dXM5Jo2tX3z9lwo+WOtcJH3K6tu94pSq7UgtzBn8+qT1WvnM6hvBFo0/c/BalpnemFuoGfyLxhvllPKkUwhfNuv2Hn1TndmW8Y+ddfdhFGmaos2ZFnMuEF4rwQhFeKMKHXIce5FwnfMhVbLwk6zrhw27+7KzLhBeK8EIRXijCC0V4ocId/rKuzRZbal2dbDiEO/w1G2yjKyfadkOO8EIRXijCC0V4oQgvFOGFIrxQhBeK8EIRXijCC0V4oQgvFOGFIrxQhBeK8EIRXijCC0V4oQgvFOGFIrxQhBeK8EIRXijCC0V4oQgvFOGFIrxQhBeK8EIRXijCC0V4oQgvFOGFIrxQhBeK8EIRPgxuOiHvEcKHwU+626/J+LPBdoQPhTGXPtS14pLKPCYIHw6TP/X0oY17L899gPBh8KW13csurVIz9+U+QvgwuPfigffyx3049xHCh8KYiho+uUsjJfwVPcefdjiPN3dF+HDY8S6lzv1bXiOED4Pu/juhojuvEcKHwS9jE6KxR/MaIXwYTFze3ftIQ14jhBeK8GHwpSPZ/kS8FeHDoOeCvEcIHwZbI3mPED4MrvzKuHxHCB8GWvMxfgQp4V0gfMhFW+KHEvGFGd/CIXwYnLCm66S7a7JutbU2V9c0xVY51wkfBg9+W4/93b1Zt3oHvlMf2e1cJ3wY/KNeq8ldWbfWtE6rrmqMtTnXCR8GXVVa1ezNuhVdEO9LdC6qd64TPgwemaen3pf9Xb2J5PC/aIxajLaN+syUtr7dt9fmNSI5/M717WbP3mkbDQ4u5zLtbrZsnvxT26jPWL5yx+VcpvCE7zfuq9dkXc+4nJuzZEB7rCSn9RoIX7jIX7IuZ1zO1U0dcMP8Up2YDeELN3t/1mUu5zKFJ3zyI/wrX85rhPAGgQrvAuENCF8KhC+M1nk/FIPwBoEK/6mlDZOXfiHrVofh/wThDQIVvrNGqbHZf3auYuMlWdcJbxCo8N3j+q/Pe7LvzZ+ddZnwBoEK/8DyhoaHHslrhPAGgQo//r6u3pWT8hohvEGgwrtAeINAhbc82NKE8AaBCm95sKUJ4Q0CFd7yYEsTwhsEKrzlwZYmhDcIVHgebOkgJTwPtnSQEv6l6XmPlCr8W1fa7LGNEv41Xb047x8RKFX4j91oewz7Adso4V+Tj38+/mPX2XZ7bZuELwbCGwQn/Kv9/67Le4rwBsEKn9+7+STCGxDeG4QvGsJnIrwR4Q2CE167eIwt4Y2CE94dwhsQ3huE9xnCGxDeG4T3GcIbEN4bhPcZwhsQ3huE9xnCGxDeG4T3GcIbEN4bhPcZwhsQ3huE9xnCGxDeG4T3GcIbEN4bhPcZwhsQ3huE9xnCGxDeG4T3GcIbEN4bhPcZwhsQ3huE9xnCGxDeG4T3GcIbEN4bhPcZwhsQ3huE9xnCGxDeG4T3GcIbEN4bhPcZwhsQ3huE9xnCGxDeG4T3GcIbEN4bhPcZwhsQ3huE9xnCGxDeG4T3GcIbEN4bhPcZwhsQ3huE9xnCGxDeG4Qvk2hL/FAivrDOuU54g7CEb2ttrq5piq1yrhPeICzheyuTTyO7neuENwhL+DWt06qrGmNtznUPw1841+KOm2yjhC+a6IJ4X6JzUb1z3cPwWz5t8fT9tlHCl86cJQPaY57d4lO2zbuX2XYJXzp1UwfcMN+zWyS8H91TNXlFz967ink5R3g/0rWr758y4UdLneuENwhP+L7jlarscq4T3iA04U/c/Balpnc61wlvEJbw6/YfflKd25WRmfAGYQmvIg0z1FmzIs5lwhuEJrwB4Q0InzPCBwnhDQifM8IHCeENCJ8zwgcJ4Q0InzPCBwnhDQifM8IHCeENCJ8zwgcJ4Q0InzPCBwnhDQifM8IHCeENCJ8zwgcJ4Q0InzPCBwnhDQifM8IHCeENCJ8zwgcJ4Q0InzPCBwnhDQifM8IHCeENCJ8zwgcJ4Q0In7OQhX8wajHOdruBQHiDc/raLXadbLvhICC8wbt32EbvOtW2GwSENyB8zggfJIQ3IHzOCB8khDcgfM4IHySENyB8zggfJIQ3IHzOCB8khDcgfM4IHySENyB8zggfJIQ3IHyay7dutsj4Q0fpCO8zeYWff5lt11qP8D5DeAPCpyH8MMKnIXyQEN6A8GkIP4zwaSSFf67Tcl37pwdsoz5BeAN7+G0fsGyOW20b9QnCGxA+DeGHET4N4YcQPg3hfYbwBoRPQ/hhhE9D+CGET0N4nyG8QQHhoy+utHj4RNsNlwzhDQoIP+XlqRats2w3XDKENygk/Eu20e/5M/ypMy0WzbXdFOGHBDL832MW8VttN0X4IYEMb32M9K9abLuEH0L4NIQfRvhcRwlfDIQ3IHwawg8LTvhoS/xQIr6wzrlOeIOihW/99lyLc2yjbrS1NlfXNMVWOdcJb1C08Gt/9mmLtbZRN3ork08ju1MLc5YMaHe03LXE4p9bbLv/sW1uj7se3fiibfeVH1s2n9pnG+1bYdl89IBttOfXls0Hj9hG//2Mbdfz8Gtap1VXNcbaUgt1g185bn7dyJd7g+3LzKc323bPtG2eOt316LTTXY82vtm2e5Zt85QZtt0Zb7LtWs/pjEbb7iSvw0cXxPsSnYvqvb5dAAAAAAAAAADgrbjtl5ba7Q3a6J4trkdftP5yV6sd/ngEjpP1+/F+HH0y4np05UTXowX81iufPPTKifA5IXzZRwnvDcLnhPBlHyW8Nwifk/CF/23gRt2HXzHB9ejiJtej3znX9WgxjWG0yKOV7v+nAgAAAAAAQLCLXzjwwnvdjX5o24G1br+SWdHhbi7a1rM6WuJjFvSaFnD/FtWo/ReOuuJfrkZPOvyO6pvXuTvsFzdod4OxxWMWW39NRxGOWchrWsD9W1yV74+Mu3S7q9Hz71VqYre7w86+xGWEeLNqjpf4mIW8pgXcv8VWq//n+ttHFXff6XbUZYS+alV9qMTHTHL/mhZy/xZJhx64J8bessnl6Hu2xEa7ParLCIkqVZNwN1pIeFev6RA392/xvXGhUpP7XI1GWlx/aqdcR+hsVI3WX09VhGMW8poWcP8WV2XPeZEbn3E1+s6O8bW1tW4P7DLCD1siLQtLfMxCXtMC7t8iO++5nvW2X/9m9g2d5Pa4LgfHP7Zntetf6OT2ZAt5Td3fvwAAAAAAAAAAAAAAAAAAAN4o4OckEGSEF4rwYqy+Tqk7blUffP7A3psHwl+7t/vGcp8Uim9euxr90ilq680VZx4dCN97RlN7uU8KxVfdM+l9Tyg16uxrl+mB8I+2zXX9Q40IkJ9+9qGPKPWLn116wmD4yJyHeYuX4IKNu8YodfC0yLV6dDL8zqZTe8p9TiiBij0/7H/6+Ze3feXxZcnwn9u/75PlPicAAAAAAAAAAAAAAAAAgC/9H7wtkGqOPMsXAAAAAElFTkSuQmCC" alt=""/> </p>

<pre><code class="r">histNormalWrapper(1000, breaks=50)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/> </p>

<h1>Lazy evaluation</h1>

<pre><code class="r">colSorter &lt;- function(data.matrix, col1, col2, col3) {
    ordered.idcs &lt;- order(data.matrix[, col1], data.matrix[, col2], decreasing=TRUE)
    sorted.matrix &lt;- data.matrix[ordered.idcs, ]
    return(sorted.matrix)
}

identical(earnings_ordered, colSorter(earnings, &quot;earn&quot;, &quot;height&quot;))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Even though we&#39;ve called our function with an insufficient number
of actual arguments to match our formal arguments, R doesn&#39;t
complain.  This is because R doesn&#39;t check to see if col3 has been
associated with an object until R needs to retrieve the object.
Since col3 isn&#39;t referenced in the body of the function,
R never needs to retrieve its value and find that it can&#39;t.</p>

<p>Note that default arguments are lazily evaluated.</p>

<pre><code class="r">f &lt;- function(x=ls()) {
  a &lt;- 1
  x
}
f()
</code></pre>

<pre><code>## [1] &quot;a&quot; &quot;x&quot;
</code></pre>

<pre><code class="r">f(ls())
</code></pre>

<pre><code>##  [1] &quot;a&quot;                 &quot;b&quot;                 &quot;colSorter&quot;        
##  [4] &quot;e&quot;                 &quot;earnings&quot;          &quot;earnings_ordered&quot; 
##  [7] &quot;f&quot;                 &quot;g&quot;                 &quot;histNormal&quot;       
## [10] &quot;histNormalWrapper&quot; &quot;max&quot;               &quot;newFunction&quot;      
## [13] &quot;ord&quot;               &quot;square&quot;            &quot;x&quot;
</code></pre>

<h1>Control flow</h1>

<p>More interesting when there is control flow:</p>

<ul>
<li>branching</li>
<li>looping</li>
</ul>

<h1>Branching: <code>if</code>-<code>else</code> statements</h1>

<pre><code class="r">val &lt;- rnorm(1)
val
</code></pre>

<pre><code>## [1] -0.1758
</code></pre>

<pre><code class="r">if (val &lt; 0) {
  &quot;val is negative!&quot;
} else {
  &quot;val is positive&quot;
}
</code></pre>

<pre><code>## [1] &quot;val is negative!&quot;
</code></pre>

<p>Chaining <code>if</code> statements:</p>

<pre><code class="r">val &lt;- rnorm(1)
val
</code></pre>

<pre><code>## [1] -0.4097
</code></pre>

<pre><code class="r">if (val &lt; -1) {
  &quot;val is more than one standard deviation below the mean.&quot;
} else if (abs(val) &lt;= 1) {
  &quot;val is within one standard deviation of the mean.&quot;
} else {
  &quot;val is more than one standard deviation above the mean.&quot;
}
</code></pre>

<pre><code>## [1] &quot;val is within one standard deviation of the mean.&quot;
</code></pre>

<p>Zero evaluates to <code>FALSE</code>, all other numbers evaluate to <code>TRUE</code>. (And the string &ldquo;true&rdquo; evaluates to <code>TRUE</code> too&hellip; but not other strings.)</p>

<pre><code class="r">val &lt;- 3.1
if (val) {
  &quot;3.1 is true?&quot;
}
</code></pre>

<pre><code>## [1] &quot;3.1 is true?&quot;
</code></pre>

<pre><code class="r">if (&quot;true&quot;) {
  &quot;true is true?&quot;
}
</code></pre>

<pre><code>## [1] &quot;true is true?&quot;
</code></pre>

<pre><code class="r">if (&quot;bear&quot;) {
  &quot;bear is true?&quot;
}
</code></pre>

<pre><code>## Error: argument is not interpretable as logical
</code></pre>

<h1><code>for</code> loop</h1>

<p>Abstract structure of <code>for loop</code>:</p>

<pre><code class="r">for (variable in set) {
  statement
}
</code></pre>

<p>More concretely:</p>

<pre><code class="r">myseq &lt;- seq(5,20,by=5)
for (i in myseq) {
  print(i)
}
</code></pre>

<pre><code>## [1] 5
## [1] 10
## [1] 15
## [1] 20
</code></pre>

<p>And more directly:</p>

<pre><code class="r">for (i in seq(2,8, by=2)) {
  print(i)
}
</code></pre>

<pre><code>## [1] 2
## [1] 4
## [1] 6
## [1] 8
</code></pre>

<p>But is it a function?</p>

<pre><code class="r">&#39;for&#39;(i, seq(2,8, by=2), print(i))
</code></pre>

<pre><code>## [1] 2
## [1] 4
## [1] 6
## [1] 8
</code></pre>

<h1><code>while</code> loop</h1>

<p>Abstractly:</p>

<pre><code class="r">while (condition) {
  statements
}
</code></pre>

<p>Concretely:</p>

<pre><code class="r">i &lt;- 0
while (i &lt; 10) {
  i &lt;- i + 1
  print(i)
}
</code></pre>

<pre><code>## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10
</code></pre>

<p>It&#39;s easy to create infinite loops!</p>

<h1>Examples: Fibonacci numbers</h1>

<p>First 12 Fibonacci numbers:</p>

<pre><code class="r">myseq[1] &lt;- 0
myseq[2] &lt;- 1
for (i in seq(3,12)) {
  myseq[i] &lt;- myseq[i-2] + myseq[i-1]
}
myseq
</code></pre>

<pre><code>##  [1]  0  1  1  2  3  5  8 13 21 34 55 89
</code></pre>

<p>Fibonacci numbers less than 500:</p>

<pre><code class="r">myseq[1] &lt;- 0
myseq[2] &lt;- 1
i &lt;- 2
currentVal &lt;- 1
while (currentVal &lt; 500) {
  myseq[i+1] &lt;- currentVal
  currentVal &lt;- myseq[i] + myseq[i+1]
  i = i+1
}
myseq
</code></pre>

<pre><code>##  [1]   0   1   1   2   3   5   8  13  21  34  55  89 144 233 377
</code></pre>

<h1>Flow control: <code>next</code> and <code>break</code> statements</h1>

<p><code>next</code> skips the current evaluation of the loop statements:</p>

<pre><code class="r">for (i in seq(1,10)) {
  if (i == 5) {
    next
  }
  print(i)
}
</code></pre>

<pre><code>## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10
</code></pre>

<p><code>break</code> immediately ends loop evaluation:</p>

<pre><code class="r">val &lt;- 0
i &lt;- 0
while(TRUE) {
  i &lt;- i + 1
  val &lt;- val + rnorm(1)
  if (abs(val) &gt; 3) {
    break
  }
}
val
</code></pre>

<pre><code>## [1] -3.784
</code></pre>

<pre><code class="r">i
</code></pre>

<pre><code>## [1] 7
</code></pre>

<h1>Avoid loops</h1>

<p>Loops are frequently the wrong solution.</p>

<pre><code class="r">vals &lt;- rnorm(100)
maxVal &lt;- vals[1]
for (val in vals) {
  if (val &gt; maxVal) {
    maxVal = val
  }
}
maxVal
</code></pre>

<pre><code>## [1] 1.697
</code></pre>

<p>Try to use builtin functions instead:</p>

<pre><code class="r">max(vals)
</code></pre>

<pre><code>## [1] 1.697
</code></pre>

<p>Operate directly on vectors rather than looping over them:</p>

<pre><code class="r">myseq &lt;- seq(2,20, by =2)
for(i in seq(1,10)) {
  myseq[i] &lt;- myseq[i] + 2
}
myseq
</code></pre>

<pre><code>##  [1]  4  6  8 10 12 14 16 18 20 22
</code></pre>

<pre><code class="r">seq(2,20, by =2)+2
</code></pre>

<pre><code>##  [1]  4  6  8 10 12 14 16 18 20 22
</code></pre>

<h1>Breakout (colSums 3 ways)</h1>

<p>For this breakout, you will see how long it takes to compute the
columns sums of a matrix in 3 different ways.</p>

<ol>
<li><p>Create a function (rnormMatrix) that takes two arguments (r,c) and
returns a rxc matrix of values drawn from a standard normal distribution.</p></li>
<li><p>Create a function (colSums.builtin) which takes a matrix and
returns a vector of the column sums.  Implement this function
using R&#39;s builtin function colSums.</p></li>
<li><p>Create a function (colSums.apply) which takes a matrix and
returns a vector of the column sums.  Implement this function
using R&#39;s builtin function sum and an apply statement.</p></li>
<li><p>Create a function (colSums.for) which takes a matrix and
returns a vector of the column sums.  Implement this function
using R&#39;s builtin function sum and a for loop.</p></li>
<li><p>Create a few different sized matrices using rnormMatrix and
see how long each of the colSums.xxx functions takes to
compute the column sums.  Compare the results from the
different function calls to make sure you are computing the
same result in each function.</p></li>
</ol>

</body>

</html>
